import { Given, When, Then } from '@cucumber/cucumber';
import { expect } from '@playwright/test';
import fs from 'fs/promises';

Given('I send a POST request to {string} with data from {string}', async function (url: string, filePath: string) {
  // Read the request body from the JSON file
  const requestBody = await fs.readFile(filePath, 'utf-8');
  const parsedBody = JSON.parse(requestBody);

  // Perform the POST request using Playwright
  const response = await this.page.request.post(url, {
    data: parsedBody,
  });

  // Save the response for assertions
  this.response = response;
});

Then('the response status should be {int}', async function (statusCode: number) {
  // Check if the response status matches the expected status code
  expect(this.response.status()).toBe(statusCode);
});

Then('the response body should contain {string} with value {string}', async function (key: string, value: string) {
  // Parse and validate the response body
  const responseBody = await this.response.json();
  expect(responseBody[key]).toBe(value);
});

========================
Feature: Sending a POST request with data from a JSON file

  Scenario: Successfully sending a POST request
    Given I send a POST request to "https://jsonplaceholder.typicode.com/posts" with data from "requestBody.json"
    Then the response status should be 201
    And the response body should contain "title" with value "foo"

============================


import { Then } from '@cucumber/cucumber';
import { expect } from '@playwright/test';

Then(
  'the response body should contain {string} with value {string}',
  function (key: string, expectedValue: string) {
    if (!this.response) {
      throw new Error('No response found');
    }

    const responseBody = this.response.data;

    // Check if the key exists in the response
    expect(responseBody).toHaveProperty(key);

    const actualValue = responseBody[key];
    console.log(`Validating key: "${key}", Expected Value: "${expectedValue}", Actual Value: "${actualValue}"`);

    // Convert the expected value to its actual type
    let parsedExpectedValue: any = expectedValue;
    if (expectedValue === 'true' || expectedValue === 'false') {
      parsedExpectedValue = expectedValue === 'true'; // Convert to boolean
    } else if (!isNaN(Number(expectedValue))) {
      parsedExpectedValue = Number(expectedValue); // Convert to number
    } else if (expectedValue === '') {
      parsedExpectedValue = ''; // Empty string
    }

    // Validate the actual value matches the expected value
    expect(actualValue).toBe(parsedExpectedValue);
  }
);
====


import * as fs from 'fs';
import * as path from 'path';

/**
 * Reads a JSON file from the given path and returns the parsed JSON object.
 * @param jsonPath - The relative or absolute path to the JSON file.
 * @returns Parsed JSON object.
 * @throws Error if the file cannot be read or parsed.
 */
export async function readJsonFile(jsonPath: string): Promise<any> {
    try {
        const absolutePath = path.resolve(jsonPath); // Resolve to an absolute path
        const jsonData = fs.readFileSync(absolutePath, 'utf-8'); // Read file contents
        return JSON.parse(jsonData); // Parse and return JSON
    } catch (error) {
        throw new Error(`Failed to read or parse JSON file: ${error.message}`);
    }
}


==

import { test } from '@playwright/test';
import { readJsonFile } from './utils/readJsonFile'; // Assuming this file is in the 'utils' folder

test('Read JSON file and log its contents', async () => {
    const jsonPath = './request_body.json'; // Path to your JSON file
    const jsonData = await readJsonFile(jsonPath);
    console.log('Parsed JSON:', jsonData);
});
===
When('I retrieve the project name with value {string}', async (expectedValue: string) => {
  // Extract the project name
  retrievedProjectName = jsonResponse.Projects.find(
    (project: any) => project.ProjectName.Value === expectedValue
  )?.ProjectName.Value;
});

